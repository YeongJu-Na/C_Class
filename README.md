# C_Class
IoT-2021-1 Class resource
2021-03-02 IoT Class daily report
### C언어 1강
printf의 사용 - 서식지정자, 이스케이프 시퀀스

### C언어 2강
* 변수:
void타입은 포인터 쓸 때 많이 사용
 --> unsigned는 실수형 자료형x
 --> 3byte, 5 등은 메모리 관리 문제, 정렬 문제(2의 배수형태로?) 등으로 쓰지x

* 상수:
리터럴 상수 -> int a=3+4;	→ 메모리 공간차지함 → | 3 | 4 | 7(a) |

* 연산자: shift연산자
비트shift로 <<1은 *2, >>1은 /2	 ⇒ c++에서는 입출력 관련 문자
 /a+=b; // cpu의 클럭속도를 덜 잡아먹음 -> 선호방식

* 입력받기: scanf
서식문자열?에는 다른내용(prompt ?) 들어가면 안됨
 /변수의 타입과 다른 값 입력 시 오류 → 이러한 오류발생 가능성이 많아서 윈도우즈 프로그램에선 다른 것으로 대체하여 사용 → 추후 학습할 것

* 조건문
switch문이 ifelse에 비해 장점이 될 수 있는 부분 : 많은 elseif중 어느것도 해당되지 않는 경우(else) 앞의 모든 elseif 들을 모두 거쳐야함→ 시간 delay발생  (1st조건 만족하는 값과 else만족하는 값간에 동기화 어려울 수 있다…..
⇒ 반면 switch는 동일 → 제어 타이밍 중요한 경우 필요

### C언어 3강
* scanf:  ‘ ‘, ‘\t’, ‘\n’만날때 까지 데이터 가져오고 버퍼에서 삭제
--->  %c, 문자 1개 받는 경우, 버퍼 내의 enter도 하나의 문자로 인식되어 새로운 입력을 받지 않고 남은 버퍼 값으로 추출해냄  ⇒ 이런 값은 0(또는 NULL)으로 구별가능(입력받은 문자열의 종료도 알 수 있음)  (개행문자(\n): 입력 종료로 받아들임)

* getch()함수- #include <conio.h> 필요-> console의 con / 단일 키 값을 반환
⇒ scanf는 반드시 enter키 입력필요했음 , 얘는 뭐가됐든 그대로 char값으로 되돌림, scanf보다 lowlevel
⇒ 원래는 int로 반환해줌

* 16진수 비트 연산 → 대, 소문자 변환- 대문자는 4?(16) / 소문자는 6? ⇒ 4=0100, 6=0110

* 함수 - 함수의 원형 미리 선언해야

* 배열
  * 많은 양의 데이터 일괄처리 시 유용
  * char배열: 문자열의 끝은 항상 0으로 인식하므로 반드시 필요 → 원소(문자) 수 + 1개의 방 필요 ⇒  고려하지 않고, 크기이상의 원소들 넣으면 쓰레기값들 나올 수 있음(배열의 끝을 인식하지 못해서)
    * for문의 조건문이 0이 아닌 동안 루프 실행: for(int i=0;buf[i];i++) == for(int i=0;buf[i]!=0;i++)
    * c컴파일러는 배열의 길이 신경쓰지 않음..!-> 즉, 배열의 길이 등을 검사해서 오류 출력해주지 않음-> 개발자가 직접 신경써야함 ex) int arr[3]={1,2,3}; arr[3]=100; 0부터3까지 출력시 arr[3]으로도 나옴 but, arr 크기출력해보면 3으로 나옴
    * 배열 초기화 시, 개별 인덱스만 초기화 하거나 초기화하지 않을 경우 쓰레기값 나옴 → int arr[3]; arr[0]=10; 이렇게 -> 0번만 제대로 나오고 나머지는 쓰레기값 → but, int arr[]={10}; → 10 0 0 나머지는 0으로 나옴
    * 배열 크기 명시하기- 2차원에서 행값, 열값 둘다 안하면 error

* 배열과 포인터

  * 1차원 배열에서 buf[]를 매개변수로 가능 but, 2차원은 buf[][] 안됨
  * 2차원행렬에선 *(a+1)과 a[1]은 모두 1행의 주소  → 1차원이면 1인덱스의 값이지만 2차원이면 1행의 주소가 됨
  * 2차원포인터 ⇒ int**a  / 매개변수로 2차원 배열 넘길때 int (*ptr)[4]

### C언어 4강
* 포인터
    * void타입 - 정해지지않은 주소 ,데이터타입 없으므로 +1연산 시 그대로 +1, 포인터 연산, 메모리 참조와 관련된 일에 활용x
    * 주소 블록 그림=> 메모리 맵(memory map)
    * int *pa=&a;	// 포인터 변수 pa는 a의 주소	⇒ 초기화 시, 주소값아닌 특정 값 넣으면 system area잘못건드릴수 있음 주의
→  DMA: direct memory access- 나중에 프로젝트로 ? 장치드라이버 관련해서 할 때 , 확장 슬롯으로 데이터 주고받는 게 dma인데 이거할때는 포인터값으로 특정 주소 대입하는 경우가 있기는 함
    * 주소값 확인할 때, 16진수가 보기 편함→ %08x  //8자리의 16진수 표기, 빈 왼쪽칸은 0으로 채움
    * 배열 초기화: int *a = {1,2,3};    // int a[3]={1,2,3}; 과 같음
  * 활용 예:  swap함수 만들기 -> 변수의 주소(포인터)를 넘겨줘야 값 변경 적용됨
	
  * 문자열 표현방식
    * 배열 기반의 문자열 변수 - 1차원의 char 배열 →  char str1[5]=”abcd”;
    * 포인터 기반의 문자열 상수 → char *str2=”abcd”;	// char * == string

  * 포인터 배열- 배열의 요소로 포인터를 지니는 배열 → int* arr1[10];
    * 1차원 배열 처럼 보이나 각각은 다른 위치(변수) 가리키고있어 실제론 2차원 배열
    * case연산 → > 포인터도 가능  ex) 포인터 메모리 공간 동적으로 늘려야하는 경우, int *p1; double *p2; void*p3;
    * malloc(): 리턴타입 void포인터 

* 함수 포인터와 void포인터
  * 함수도 메모리 공간에 존재, int (*fptr) (int); fptr = fct; 
  *  쓰임: 실행파일(exe), dll(dynamic linked library,필요에 따라 동적으로 로드) 이럴 때 

* 구조체: 하나 이상의 기본 자료형을 기반으로 사용자 정의 자료형을 만들 수 있는 문법 요소
  * 선언: struct 이름{ int x; int y;   // 구조체 멤버  };	// 중괄호 뒤 세미콜론 
⇒ 소스파일에 해도 되지만 헤더파일에 하는게 일반적
  * 구조체의 확장 ~ c++ (정확히 맞지는 않지만)(-->  구조체가 확장된 class개념 많이 씀)
  * 정의 및 변수 선언
    * 메인 밖에서 : struct point{int x; int y;} p1, p2, p3;       //전역변수처럼
    * struct만 메인 밖에서 정의 후, 메인 안에서 따로 변수 선언 struct point p1, p2, p3;
  * 구조체 변수의 접근: 점 사용 ⇒ p1.x=10;
  * 초기화: 배열 초기화 문법과 비슷: struct person p = {“yeongju na” , “02-1021”, 20};
  * 구조체와 포인터: struct person * pman = &p;
    * 포인터로 구조체 멤버(x)받아오기:  (*pman).x 또는 pman->x

* typedef: 구조체나 자료형을 매번 정의하기 귀찮아서 아예 자료형처럼 만드는것
    * 이것도 구조체와 함께 헤더파일에 많이
  * 기본자료형: 주로 호환성을 위해 사용 (ex) typedef int INT; 
  * 구조체에 사용: 선언할 때 일일이 struct 안써도 됨 
    * typedef struct 구조체명 자료형처럼쓸이름 => typedef struct data data;
    * typedef struct Data{ int d1; int d2; } data;	//정의할 때 typedef까지
    * typedef struct{ int d1, int d2} data;	//이름 한번만 짓기(구조체명과 자료형명 같은 경우)

* UNION- 공용체; 하나의 메모리 공간을 둘 이상의 변수가 공유하는 형태 
  * 특별한 용도의 키워드 - 사용 예) 멤버변수로 char buf[256]; struct data;  //통신에서 일단 들어오는 데이터 버퍼에 다 받은 후 사용할 땐 struct에 정의된 구조에 따라 데이터 정제하는 형태로 사용
  * struct처럼 사용하지만, struct은 메모리 공간 손실x  / union은 멤버들 중 가장 큰 데이터타입의 공간만큼만 가짐 ⇒ 이미 값이 들어간 후 다른 멤버 들어온 경우 이미 있던 거 overwrite(?)

* Enum- 열거형 
  * 활용: 1주일 요일 숫자로  / 쓸기회 거의 x, 볼 기회는 많음 - 라이브러리 볼 때
  * 특정 값에 의미 부여 o, 가독성 높일 수 o, 숫자 명시 x면 0부터, 일부 명시된 경우, 그 이후의 숫자는 명시된 값 +1, +2, ~~~

* sizeof()는 함수아니고 매크로-> 매개변수로 배열을 넣는 것은 옳지 않다! ==> 선언된 곳에서는 작동할수도 있지만 100프로의 답(프로그램의 안정성)을 보장할수 없다
* const: 메모리 확보 영역이 조금 다름, 상수(변경불가), const int*p 

### C언어 5강
* ASCII - 1Byte= 8Bit로 255까지 표현 가능하나 msb는 확장형?으로 실제론 7비트만 사용
  * 4칸(32개단위)으로 나누는게 보기편하고 첫번째라인은 제어문자, 3번째와 4번째는 대소문자의 비교 가능

* sizeof: 매크로 함수(macro function): 컴파일러가 컴파일당시에 실행 ⇒ 배열을 인수로 받는 함수를 만든 경우, sizeof(arr)는 주소값의 크기를 반환 → 즉, 제대로 동작x

* C 표준함수
  * 입출력: 파일, 콘솔(키보드/모니터), 소켓 입출력(tcp/ip소켓이라고 함)
    * 스트림: 대기 문자열/buffer 
    * fgets(char*str, sizeof(str),stdin);	//stdin- 스트림이지만 이 함수는 파일포인터로
    * puts(), fputs등
  * 문자열 처리 함수(<string.h>) - strlen, strcpy, strcat, strcmp(string끼리는 비교==로 못함)
    * strcmp결과: 양수이면 str1(1st인자)가 더 큰 경우
  * 문자열 변환함수(atoi):<stdlib.h>
    *  int atoi(char *ptr)(Ascii To Integer), long atol(char* ptr), double도 있음
  * 부분문자열: 인덱스 3부터보려면 str+3하면됨! ⇒ 포인터를 인수로
